package com.visarut.myapplication.view.feature.featureHomeimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.visarut.myapplication.data.response.Coinimport com.visarut.myapplication.data.response.CoinDetailimport com.visarut.myapplication.data.response.Statsimport com.visarut.myapplication.domain.usecase.GetCoinUseCaseimport com.visarut.myapplication.domain.usecase.SearchCoinUseCaseimport kotlinx.coroutines.launchclass HomeViewModel(    private val getCoinUseCase: GetCoinUseCase,    private val searchCoinUseCase: SearchCoinUseCase) : ViewModel() {    val coinList: MutableLiveData<List<Coin>> = MutableLiveData()    private val coinDetail: MutableLiveData<CoinDetail> = MutableLiveData()    private val coinStat: MutableLiveData<Stats> = MutableLiveData()    val isShowTopRank = MutableLiveData(true)    val isShowSkeleton = MutableLiveData(true)    val isShowRetry = MutableLiveData(false)    val errorMessage = MutableLiveData("")    companion object {        const val DEFAULT_OFFSET = 0        const val DEFAULT_LIMIT = 20        var isLoadMore = true    }    init {        fetchCoin()    }    fun fetchCoin() {        viewModelScope.launch {            val getCoinInput = GetCoinUseCase.Input(DEFAULT_OFFSET, DEFAULT_LIMIT)            getCoinUseCase.execute(getCoinInput)                .onSuccess {                    coinList.value = it.data.coins                    coinStat.value = it.data.stats                }                .onFailure {                    // handle error                    handleFetchCoinError(it)                    showRetryButton()                }            hideSkeleton()        }    }    fun clearData() {        coinList.postValue(emptyList())    }    fun isLoadMore(): Boolean {        val currentListSize = coinList.value?.size ?: 0        isLoadMore = currentListSize < coinStat.value?.total ?: 0        return isLoadMore    }    fun fetchMoreCoin() {        val currentListSize = coinList.value?.size ?: 0        viewModelScope.launch {            val getCoinInput = GetCoinUseCase.Input(currentListSize, DEFAULT_LIMIT)            getCoinUseCase.execute(getCoinInput)                .onSuccess {                    val response = it.data.coins                    var tempObj = coinList.value                    val oldList = tempObj?.toMutableList()                    oldList?.addAll(response)                    tempObj = oldList                    tempObj.apply {                        coinList.value = this                        isLoadMore()                    }                }                .onFailure {                    // handle load more error                    handleLoadMoreError(it)                }        }    }    private fun handleLoadMoreError(it: Throwable) {        TODO("Not yet implemented")    }    fun searchCoin(query: String) {        if(query.isNotEmpty()) {            viewModelScope.launch {                val searchCoinInput = SearchCoinUseCase.Input(query)                searchCoinUseCase.execute(searchCoinInput)                    .onSuccess {                        coinList.value = it.data.coins                        coinStat.value = it.data.stats                    }                    .onFailure {                        // handle search coin error                        handleSearchCoinError(it)                    }            }        }    }    private fun handleSearchCoinError(it: Throwable) {        TODO("Not yet implemented")    }    fun hideTopRank() {        isShowTopRank.postValue(false)    }    fun showTopRank() {        isShowTopRank.postValue(true)    }    fun showSkeleton() {        isShowSkeleton.postValue(true)    }    fun hideSkeleton() {        isShowSkeleton.postValue(false)    }    fun showRetryButton() {        isShowRetry.postValue(true)    }    fun hideRetryButton() {        isShowRetry.postValue(false)    }    private fun handleFetchCoinError(throwable: Throwable) {        when (throwable.localizedMessage) {            "timeout" -> errorMessage.postValue("Time out")            else -> errorMessage.postValue("Error")        }    }}